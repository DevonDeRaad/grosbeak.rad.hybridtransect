---
title: "Grosbeak.snp.filtering"
format:
  html:
    code-fold: show
    code-tools: true
toc: true
toc-title: Document Contents
number-sections: true
embed-resources: true
---

<iframe src="https://macaulaylibrary.org/asset/619237930/embed" height="500" width="640" frameborder="0" allowfullscreen>

</iframe>

## Load packages and read in unfiltered vcf {style="color: red"}

This vcf comes straight out of mapping raw RADseq reads to a publicly available *Ceyx* reference genome and calling SNPs using [Stacks](https://catchenlab.life.illinois.edu/stacks/manual/).

```{r}
#| output: false
library(vcfR)
library(SNPfiltR)
library(StAMPP)
library(adegenet)
library(ggplot2)
#read vcf
v<-read.vcfR("~/Downloads/populations.snps.vcf")
```

I will now follow the SNP filtering pipeline outlined in detail in the documents of the SNPfiltR R package (see [SNPfiltR vignettes](https://devonderaad.github.io/SNPfiltR/)).

## Implement quality filters that don't involve missing data

This is because removing low data samples will alter percentage/quantile based missing data cutoffs, so we wait to implement those until after deciding on our final set of samples for downstream analysis

```{r}
#| layout-ncol: 3
#| column: page

#check the details of the unfiltered dataset
v

#visualize distributions
hard_filter(v)

#hard filter to minimum depth of 3, and minimum genotype quality of 30
v<-hard_filter(vcfR=v, depth = 3, gq = 25)
```

Use the function `allele_balance()` to filter for allele balance from [Puritz SNP filtering tutorial](http://www.ddocent.com/filtering/) "Allele balance: a number between 0 and 1 representing the ratio of reads showing the reference allele to all reads, considering only reads from individuals called as heterozygous, we expect that the allele balance in our data (for real loci) should be close to 0.5"

```{r}
#test
filter_allele_balance(v)
#execute allele balance filter
v<-filter_allele_balance(v, 0.15, 0.85)
```

We now want to implement a max depth filter (super high depth loci are likely multiple loci stuck together into a single paralogous locus, which we want to remove).

```{r}
#| layout-ncol: 3
#| column: page

#visualize and pick appropriate max depth cutoff
max_depth(v)

#filter vcf by the max depth cutoff you chose
v<-max_depth(v, maxdepth = 250)
```


Remove SNPs from the vcfR that have become invariant following the removal of questionable genotypes above, and see how many SNPs we have left after this initial set of filters

```{r}
v<-min_mac(v, min.mac = 1)
v
```


## Setting the missing data by sample threshold

Check out the exploratory visualizations and make decisions about which samples to keep for downstream analysis.

```{r}
#run function to visualize per sample missingness
miss<-missing_by_sample(v)
```

```{r}
#run function to visualize per SNP missingness
by.snp<-missing_by_snp(v)
```


Based on these visualizations, we will want to drop the worst sequenced samples that are dragging down the rest of the dataset. Drop those samples based on an approximate missing data proportion cutoff here (this can always be revised if we end up feeling like this is too lenient or stringent later):

```{r}
#run function to drop samples above the threshold we want from the vcf
vcfR.trim<-missing_by_sample(v, cutoff = .82)
#get a list of samples that got trimmed
colnames(v@gt)[!colnames(v@gt) %in% colnames(vcfR.trim@gt)]
#remove invariant sites generated by sample trimming
vcfR.trim<-min_mac(vcfR.trim, min.mac = 1)

#see what effect trimming samples had on missing data across the dataset
by.snp<-missing_by_snp(vcfR.trim)
```

## Remove lagging low-quality samples
```{r}
#identify the lagging sample
test<-missing_by_snp(vcfR.trim, cutoff = .9)
test.miss<-missing_by_sample(test)
#manually remove this sample
vcfR.trim@gt<-vcfR.trim@gt[,colnames(vcfR.trim@gt) != "P_melanocephalus_39985"]
vcfR.trim

#double check that this worked
by.snp<-missing_by_snp(vcfR.trim)

#remove SNPs that have become invariant because of sample removal
vcfR.trim<-min_mac(vcfR.trim, min.mac = 1)
vcfR.trim
```


## Remove overlapping SNPs

It is a known thing (see [this](https://groups.google.com/g/stacks-users/c/Ag8YyEFe7z0)) that Stacks will not merge SNPs if they are sequenced by separate (but physically overlapping) loci, and will instead retain the same SNP twice. To account for this, we will simply remove a SNP every time its chromosome and position have already been seen in the dataset, using the following code:

```{r}
#check # of SNPs
vcfR.trim
#generate dataframe containing information for chromosome and bp locality of each SNP
df<-as.data.frame(vcfR.trim@fix[,1:2])
#calc number of duplicated SNPs to remove
nrow(df) - length(unique(paste(df$CHROM,df$POS)))
#remove duplicated SNPs
vcfR.trim<-vcfR.trim[!duplicated(paste(df$CHROM,df$POS)),]
#check # of SNPs
vcfR.trim
```

## Setting the missing data by SNP threshold

Now we will visualize different per SNP missing data thresholds and identify a value that optimizes the trade-off between amount of missing data and the total number of SNPs retained.

```{r}
#see what effect trimming samples has had on missing data across the dataset
by.snp<-missing_by_snp(vcfR.trim)
```

Test various SNP completeness thresholds to see if proportion missing data drives sample placement in an unrooted neighbor-joining tree
```{r}
#test 70% completeness threshold
filt<-missing_by_snp(vcfR.trim, cutoff=.7)
filt
#convert to genlight
gen<-vcfR2genlight(filt)
#fix sample names to fit in <= 10 characters
gen@ind.names
gen@ind.names<-gsub("P_hybrid_","hyb", gen@ind.names)
gen@ind.names<-gsub("P_ludovicianus_","lud", gen@ind.names)
gen@ind.names<-gsub("P_melanocephalus_","mel", gen@ind.names)
gen@ind.names
pop(gen)<-gen@ind.names
#assign populations (a StaMPP requirement)
gen@pop<-as.factor(gen@ind.names)
#generate pairwise divergence matrix
sample.div <- stamppNeisD(gen, pop = FALSE)
#export for splitstree
stamppPhylip(distance.mat=sample.div, file="~/Desktop/grosbeak.rad/grosbeak.70.splits.txt")
knitr::include_graphics(c("/Users/devonderaad/Desktop/grosbeak.rad/70.splits.png"))

#test 80% completeness threshold
filt<-missing_by_snp(vcfR.trim, cutoff=.8)
filt
#convert to genlight
gen<-vcfR2genlight(filt)
#fix sample names to fit in <= 10 characters
gen@ind.names
gen@ind.names<-gsub("P_hybrid_","hyb", gen@ind.names)
gen@ind.names<-gsub("P_ludovicianus_","lud", gen@ind.names)
gen@ind.names<-gsub("P_melanocephalus_","mel", gen@ind.names)
gen@ind.names
pop(gen)<-gen@ind.names
#assign populations (a StaMPP requirement)
gen@pop<-as.factor(gen@ind.names)
#generate pairwise divergence matrix
sample.div <- stamppNeisD(gen, pop = FALSE)
#export for splitstree
stamppPhylip(distance.mat=sample.div, file="~/Desktop/grosbeak.rad/grosbeak.80.splits.txt")
knitr::include_graphics(c("/Users/devonderaad/Desktop/grosbeak.rad/80.splits.png"))

#repeat with 90% completeness threshold
filt<-missing_by_snp(vcfR.trim, cutoff=.9)
filt
#convert to genlight
gen<-vcfR2genlight(filt)
#fix sample names to fit in <= 10 characters
gen@ind.names
gen@ind.names<-gsub("P_hybrid_","hyb", gen@ind.names)
gen@ind.names<-gsub("P_ludovicianus_","lud", gen@ind.names)
gen@ind.names<-gsub("P_melanocephalus_","mel", gen@ind.names)
gen@ind.names
pop(gen)<-gen@ind.names
#assign populations (a StaMPP requirement)
gen@pop<-as.factor(gen@ind.names)
#generate pairwise divergence matrix
sample.div <- stamppNeisD(gen, pop = FALSE)
#export for splitstree
stamppPhylip(distance.mat=sample.div, file="~/Desktop/grosbeak.rad/grosbeak.90.splits.txt")
knitr::include_graphics(c("/Users/devonderaad/Desktop/grosbeak.rad/90.splits.png"))

#repeat with 100% completeness threshold
filt<-missing_by_snp(vcfR.trim, cutoff=1)
filt
#convert to genlight
gen<-vcfR2genlight(filt)
#fix sample names to fit in <= 10 characters
gen@ind.names
gen@ind.names<-gsub("P_hybrid_","hyb", gen@ind.names)
gen@ind.names<-gsub("P_ludovicianus_","lud", gen@ind.names)
gen@ind.names<-gsub("P_melanocephalus_","mel", gen@ind.names)
gen@ind.names
pop(gen)<-gen@ind.names
#assign populations (a StaMPP requirement)
gen@pop<-as.factor(gen@ind.names)
#generate pairwise divergence matrix
sample.div <- stamppNeisD(gen, pop = FALSE)
#export for splitstree
stamppPhylip(distance.mat=sample.div, file="~/Desktop/grosbeak.rad/grosbeak.100.splits.txt")
knitr::include_graphics(c("/Users/devonderaad/Desktop/grosbeak.rad/100.splits.png"))
```


Missing data does not appear to be driving sample placement, so I'm going to implement a 90% per-SNP completeness cutoff, which seems like a good trade-off.
```{r}
#set 90% completeness per SNP threshold
filt<-missing_by_snp(vcfR.trim, cutoff=.90)
#print info on the resulting dataset
filt
#get per sample missing data info
bysamp<-missing_by_sample(filt)
#print in descending order by missing data
bysamp$unfiltered.stats[order(bysamp$unfiltered.stats[,2]),]
```

## Visualize depth and quality across all retained genotypes
```{r}
#plot depth per snp and per sample
dp <- extract.gt(filt, element = "DP", as.numeric=TRUE)
heatmap.bp(dp, rlabels = FALSE)

#plot genotype quality per snp and per sample
gq <- extract.gt(filt, element = "GQ", as.numeric=TRUE)
heatmap.bp(gq, rlabels = FALSE)
```

## Separate sex-linked SNPs from autosomal SNPs

This chunk is not run (eval=FALSE is set in the chunk header) because I ended up deciding that the cutoff is too arbitrary, and reviewers would likely balk at this approach to isolating Z-linked SNPs as untrustworthy. I think this is better left for a future project with a good reference genome and whole genome data. In the meantime, I've left this code here as an artifact in case I need to come back to it in the future.
```{r, eval=FALSE}
#extract depth matrix
dpmat<-extract.gt(filt, element = "DP")
dpmat[1:5,1:5] #check
dpmat<-apply(dpmat, 2, as.numeric) #convert matrix to numeric
dpmat[1:5,1:5] #check
#read in sample sheet with sample sex info
samps<-read.csv("~/Desktop/grosbeak.data.csv")
samps<-samps[samps$passed.genomic.filtering == "TRUE",] #retain only samples that passed filtering
samps$sample_id == colnames(dpmat) #check if the dataframe is in the same order as the matrix
samps<-samps[match(colnames(dpmat),samps$sample_id),] #reorder dataframe using the command 'match'
samps$sample_id == colnames(dpmat) #check if this worked
#compare sequencing depth between male and female samples
mean(dpmat[,samps$sex=="female"], na.rm = TRUE)
mean(dpmat[,samps$sex=="male"], na.rm = TRUE)
#because male and female sequencing depth is highly uneven, I will need to subsample males to get a set of males with appropriately matched (as close to even as possible) sequencing depth
#apply(dpmat, 2, mean, na.rm=TRUE) #you can use this code to get a list of depth per sample for the next step
#manually (arbitrarily) pick out a subset of male samples that have similar depth to the female samples we sequenced and check that their depth is close to ~68.7x, like the female group shown above
mean(dpmat[,c(4:12,16,50,39,117,83,84,26,137,135,106)], na.rm = TRUE)

#compare average depth between the subset of male and female samples
x<-c()
for (i in 1:nrow(dpmat)){
  x[i]<-mean(dpmat[i,samps$sex=="male"], na.rm = TRUE)/mean(dpmat[i,samps$sex=="female"], na.rm = TRUE)
}
#look at the distribution
hist(x, breaks = 200)
#isolate the peak of the normal distribution that corresponds to the autosomal loci
sort(table(round(x,2)),decreasing = TRUE)
#1.86 is the 'typical' autosomal loci, so we will be looking for SNPs with > 1.8x this ratio (we expect 2x but want to account for noise)
table(x > 3.348)

#isolate X-linked SNPs
xSNPs<-filt[c(x>3.348),]
xSNPs
#convert to genlight
gen<-vcfR2genlight(xSNPs)
#fix sample names to fit in <= 10 characters
gen@ind.names
gen@ind.names<-gsub("P_hybrid_","hyb", gen@ind.names)
gen@ind.names<-gsub("P_ludovicianus_","lud", gen@ind.names)
gen@ind.names<-gsub("P_melanocephalus_","mel", gen@ind.names)
gen@ind.names
pop(gen)<-gen@ind.names
#assign populations (a StaMPP requirement)
gen@pop<-as.factor(gen@ind.names)
#generate pairwise divergence matrix
sample.div <- stamppNeisD(gen, pop = FALSE)
#export for splitstree
stamppPhylip(distance.mat=sample.div, file="~/Desktop/grosbeak.xSNPs.splits.txt")
knitr::include_graphics(c("/Users/devonderaad/Desktop/z.splits.png"))

#isolate autosomal SNPs
autoSNPs<-filt[c(x<3.348)]
autoSNPs
#convert to genlight
gen<-vcfR2genlight(autoSNPs)
#fix sample names to fit in <= 10 characters
gen@ind.names
gen@ind.names<-gsub("P_hybrid_","h", gen@ind.names)
gen@ind.names<-gsub("P_ludovicianus_","l", gen@ind.names)
gen@ind.names<-gsub("P_melanocephalus_","m", gen@ind.names)
gen@ind.names
pop(gen)<-gen@ind.names
#assign populations (a StaMPP requirement)
gen@pop<-as.factor(gen@ind.names)
#generate pairwise divergence matrix
sample.div <- stamppNeisD(gen, pop = FALSE)
#export for splitstree
stamppPhylip(distance.mat=sample.div, file="~/Desktop/grosbeak.autoSNPs.splits.txt")
knitr::include_graphics(c("/Users/devonderaad/Desktop/autosomal.splits.png"))
```

## linkage filter
Now filter to get unlinked SNP datasets
```{r}
#perform linkage filtering to get a reduced vcf with only unlinked SNPs
filt.thin<-distance_thin(filt, min.distance = 1000)
```

## write vcf to disk for downstream analyses
```{r}
#get info for all SNPs passing filtering 
filt
#write to disk
vcfR::write.vcf(filt, file = "~/Desktop/grosbeak.rad/grosbeak.filtered.snps.vcf.gz")

#get info for the thinned SNP dataset
filt.thin
#write to disk
vcfR::write.vcf(filt.thin, file = "~/Desktop/grosbeak.rad/grosbeak.filtered.unlinked.snps.vcf.gz")
```
